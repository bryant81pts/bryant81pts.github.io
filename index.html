<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Lightsout</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="YOLO">
<meta property="og:type" content="website">
<meta property="og:title" content="Lightsout">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Lightsout">
<meta property="og:description" content="YOLO">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Evan Hong">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Lightsout" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Lightsout</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">YOLO</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-KMP-Key-Value-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/05/14/KMP-Key-Value-md/" class="article-date">
  <time class="dt-published" datetime="2023-05-14T06:11:34.000Z" itemprop="datePublished">2023-05-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/05/14/KMP-Key-Value-md/">KMP数据持久化之Key-Value</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>常用的数据持久化方式有3种</p>
<ol>
<li>Key-Value</li>
<li>DB</li>
<li>File system</li>
</ol>
<h2 id="Key-Value"><a href="#Key-Value" class="headerlink" title="Key-Value"></a>Key-Value</h2><p>iOS中的<code>UserDefaults</code>和Android中的<code>SharedPreferences</code>通常用于存储用户的偏好设置，这两种就是各自平台典型的Key-Value存储的实现。</p>
<p>既然上述两种Key-Value存储方式是平台限定的，在KMP中当然可以用<code>expect/actual</code>的方式，定义一个统一的接口，具体实现由各自平台特性去完成，这也意味着要写两份代码，并且还有很多的样板代码。</p>
<p>Kotlin提供了个叫做<code>Multiplatform Setting</code>的库可以减少上述的工作量。</p>
<h4 id="设置Multiplatform-Setting"><a href="#设置Multiplatform-Setting" class="headerlink" title="设置Multiplatform Setting"></a>设置Multiplatform Setting</h4><p>在shared模块中的build.gradle.kts文件中为commonMain添加依赖</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;com.russhwolf:multiplatform-settings:<span class="subst">$&#123;rootProject.extra[<span class="string">&quot;settingsVersion&quot;</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>接着在androidApp模块的build.gradle.kts文件中也添加相同的依赖。</p>
<p>假设项目中用了依赖注入库Koin，则需要在commonMain中设置Koin的文件中用添加一个expect常量</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">expect</span> <span class="keyword">val</span> myModule: Module</span><br></pre></td></tr></table></figure>

<p>同样，在koin的初始化方法<code>initKoin</code>中的<code>startKoin</code>也需要添加对应的Module。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">startKoin &#123;</span><br><span class="line">  modules(</span><br><span class="line">    xxxModule,</span><br><span class="line">    xxxModule,</span><br><span class="line">    myModule, </span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就到各个平台中提供对应的实现(<code>actual</code>)。</p>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actual</span> <span class="keyword">val</span> myModule  = module &#123;</span><br><span class="line">    <span class="comment">// single表示单例</span></span><br><span class="line">     single&lt;Settings&gt; &#123;</span><br><span class="line">        AndroidSettings(<span class="keyword">get</span>())</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的AndroidSettings是安卓平台对<code>Settings</code>的实现，并需要一个<code>SharedPreferences</code>的实例来构造。Koin在遇到<code>get()</code>函数的时候会根据提供的声明上下文(AndroidSettings构造方法)去寻找匹配的参数(SharedPreferences实例)。</p>
<p>接下来在Anroid平台初始化Koin的函数<code>initKoin</code>中添加<code>SharedPreferences</code>的获取依赖函数即可。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置SharedPreferences需要一个Contenxt实例， 这里是在声明使用app实例来作为context</span></span><br><span class="line">single&lt;Context&gt; &#123; <span class="keyword">this</span><span class="symbol">@TestApp</span> &#125;</span><br><span class="line"></span><br><span class="line">single&lt;SharedPreferences&gt; &#123;</span><br><span class="line">     <span class="comment">//使用gert()函数获取Context的实例并创建一个SharedPreferences的实例</span></span><br><span class="line">    <span class="keyword">get</span>&lt;Context&gt;().getSharedPreferences(</span><br><span class="line">        <span class="string">&quot;TestApp&quot;</span>, </span><br><span class="line">        Context.MODE_PRIVATE</span><br><span class="line">      )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h4><p>在iOS平台Koin初始化文件中同样添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">actual</span> <span class="keyword">val</span> myModule = module &#123; &#125;</span><br></pre></td></tr></table></figure>
<p>在Koin的初始化方法<code>initialize</code>通过添加参数进行注入UserDefaults的实例</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">initialize</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  userDefaults: <span class="type">UserDefaults</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: KoinApplication = initKoin(</span><br><span class="line">  appModule = module &#123;</span><br><span class="line">    single&lt;Settings&gt; &#123;</span><br><span class="line">      AppleSettings(userDefaults)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>与Android不同的是，Settings在iOS平台的实现为<code>AppleSettings</code>，它需要UserDefaults的实例来初始化。</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>Settings</code>提供了许多通俗易懂的API, 使用起来几乎无门槛。</p>
<img src="https://s2.loli.net/2023/01/02/bDH8Qlo5amPdp6V.png" width="400px" />

<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userIdKey = <span class="string">&quot;USERID_KEY&quot;</span></span><br><span class="line"><span class="keyword">val</span> saved = settings.getString(userIdKey)</span><br><span class="line">settings.putString(userIdKey, <span class="string">&quot;xxxx&quot;</span>)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/14/KMP-Key-Value-md/" data-id="cllainvg20003j39k5bsw1gvh" data-title="KMP数据持久化之Key-Value" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-KMP-Serialization-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2023/01/02/KMP-Serialization-md/" class="article-date">
  <time class="dt-published" datetime="2023-01-02T15:00:00.000Z" itemprop="datePublished">2023-01-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2023/01/02/KMP-Serialization-md/">KMP中的序列化</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Kotlin在语言层级没有直接支持序列化与反序列化，但是Kotlin multiplatform提供了现成的库kotlinx.serialization支持相关功能。</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>要使用这个库需要在项目根目录的build.gradle.kts文件中加入</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath(<span class="string">&quot;org.jetbrains.kotlin:kotlin-serialization:1.6.10&quot;</span>)</span><br></pre></td></tr></table></figure>

<img src="https://s2.loli.net/2023/01/02/bZRSaWLIAi6EhmG.png" width="400px" />

<p>接着在shared文件夹中build.gradle.kts中的plugins添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kotlin(<span class="string">&quot;plugin.serialization&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2023/01/02/8OzqHQp3tUBlP7f.png" width="400px" />

<p>sync一下，库就会加入到项目中。</p>
<p>项目里会有4种build.gradle.kts文件：</p>
<ul>
<li><p>build.gradle.kts: 位于项目的根目录，用于配置Android app 和 shared module，包含依赖项下载的仓库。</p>
</li>
<li><p>shared&#x2F;build.gradle.kts： shared module的配置文件，包含插件、库、目标平台等。</p>
</li>
<li><p>androidApp&#x2F;build.gradle.kts： Android app的配置文件，定义了用于编译项目的参数、sdk版本、依赖和编译flags。</p>
</li>
<li><p>desktopApp&#x2F;build.gradle.kts:  桌面app的配置文件， 和Android对应的文件配置一致。</p>
</li>
</ul>
<h4 id="支持的序列化"><a href="#支持的序列化" class="headerlink" title="支持的序列化"></a>支持的序列化</h4><p>kotlinx.serialization支持以下序列化格式</p>
<ul>
<li><p>JSON: kotlinx-serialization-json</p>
</li>
<li><p>Protocol buffers: kotlinx-serialization-protobuf</p>
</li>
<li><p>CBOR: 一种二进制数据序列化格式  kotlinx-serialization-cbor</p>
</li>
<li><p>Properties:  一种key-value文件，例如gradle.properties。kotlinx-serialization-properties</p>
</li>
<li><p>HOCON: JSON的超集，有更好的可读性，多用于配置文件。kotlinx.serailization-hocon</p>
</li>
</ul>
<p>除了kotilin-serialization-json，其他库都还只是在beta阶段，意味着api在后续的版本中大概率会大改。</p>
<p>在shared&#x2F;build.gradle.kts中的commonMain里的dependencies中添加</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">implementation(<span class="string">&quot;org.jetbrains.kotlinx:kotlinx-serialization-json:1.3.2&quot;</span>)</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2023/01/02/ZyzUXBNI7JAlMcR.png" width="400px" />

<p>再次sync一下，就ready-to-use了。</p>
<h2 id="自定义serializer"><a href="#自定义serializer" class="headerlink" title="自定义serializer"></a>自定义serializer</h2><p>假设有如下enum</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">RECORDTYPE</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">  RECORD(<span class="string">&quot;record&quot;</span>)</span><br><span class="line">  TASK(<span class="string">&quot;task&quot;</span>),</span><br><span class="line">  AUTO(<span class="string">&quot;auto&quot;</span>),</span><br><span class="line">  HISTORY(<span class="string">&quot;history&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kotlinx-serialization-json不能解析RECORD、TASK、 AUTO、 HISTORY等关键字，因为RECORDTYPE类型并不能被识别，所以就需要自定义serializer&#x2F;deserializer。</p>
<p>首先要在自定义serializer文件中增加findByKey函数:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">findByKey</span><span class="params">(key: <span class="type">String</span>, default: <span class="type">RECORDTYPE</span> = RECORDTYPE.RECORD)</span></span>: RECORDTYPE &#123;</span><br><span class="line">  <span class="keyword">return</span> RECORDTYPE.values().find &#123; it.value == key &#125; ?: default</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findByKey函数主要起到mapping的作用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*serializer文件*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@OptIn(ExperimentalSerializationApi::class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将CustomSerializer与特定的class关联起来，此处为RECORDTYPE</span></span><br><span class="line"><span class="meta">@Serializer(forClass = RECORDTYPE::class)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓展KSerializer类并定义要被序列化或反序列化对象的类型</span></span><br><span class="line"><span class="keyword">object</span> CustomSerializer : KSerializer&lt;RECORDTYPE&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义参数读取的方式</span></span><br><span class="line">  <span class="keyword">override</span> <span class="keyword">val</span> descriptor: SerialDescriptor =</span><br><span class="line">    PrimitiveSerialDescriptor(<span class="string">&quot;RECORDTYPE&quot;</span>, PrimitiveKind.STRING)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">serialize</span><span class="params">(encoder: <span class="type">Encoder</span>, value: <span class="type">RECORDTYPE</span>)</span></span> &#123;</span><br><span class="line">    encoder.encodeString(value.value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">deserialize</span><span class="params">(decoder: <span class="type">Decoder</span>)</span></span>: RECORDTYPE &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> key = decoder.decodeString()</span><br><span class="line">      findByKey(key)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e: IllegalArgumentException) &#123;</span><br><span class="line">      RECORDTYPE.RECORD</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在RECORDTYPE的声明前加上</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable(with = CustomSerializer::class)</span></span><br></pre></td></tr></table></figure>
<p>即可</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Serializable(with = CustomSerializer::class)</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">RECORDTYPE</span>(<span class="keyword">val</span> value: String) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Data-to-Model"><a href="#Data-to-Model" class="headerlink" title="Data to Model"></a>Data to Model</h2><p>假设一个接口返回的json结构是</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;recordtype&quot;</span><span class="punctuation">:</span> xx<span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> xx<span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> https<span class="punctuation">:</span><span class="comment">//www.xx.com/xxx</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>那么项目中中对应的model为</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> recordType: RECORDTYPE</span><br><span class="line">    <span class="keyword">var</span> title: String</span><br><span class="line">    <span class="keyword">var</span> url: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时候需要在model声明前加上<code>@Serializable</code>，通过这个标记接口返回的jsonstring就会mapping转换成对应的model。</p>
<p>除此之外遇到undefinekey会有崩溃的可能，所以进行过滤处理。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> json = Json &#123; ignoreUnknownKeys = <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> content: List&lt;Record&gt; <span class="keyword">by</span> lazy &#123;</span><br><span class="line">  json.decodeFromString(RAW_JSONSTRING)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/02/KMP-Serialization-md/" data-id="cllainvg30004j39k9fiy4i9b" data-title="KMP中的序列化" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-LiveActivity-md" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/12/20/LiveActivity-md/" class="article-date">
  <time class="dt-published" datetime="2022-12-20T06:26:15.000Z" itemprop="datePublished">2022-12-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/12/20/LiveActivity-md/">LiveActivity.md</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Live Activities是iOS 16比较亮眼的新功能之一，它允许App在锁屏界面或者iPhone 14 Pro系列的Dynamic Island上展示“当前正在进行的活动“的动态信息，比如用了饿了么点了外卖后，锁屏界面就会显示你的外卖进度：</p>
<img src="https://s2.loli.net/2023/01/02/xHOEuTg7pKDiSqX.png" width="400px" />

<p>或者用直播8关注球赛，直接在锁屏界面摸鱼看文字直播：</p>
<img src="https://s2.loli.net/2023/01/02/rFJmL9Gq31hSsac.png" width="400px" />
直接省去了进入App才能查看进度状态的步骤。


<h3 id="Live-Activities基本概念"><a href="#Live-Activities基本概念" class="headerlink" title="Live Activities基本概念"></a>Live Activities基本概念</h3><p>每个Live Activity的状态可以最多持续更新8个小时，前提是App或者用户没有去手动停止。 一旦超过了8小时的限制，系统会自动杀掉对应的Activiity，此时Live Activity会自动从Dynamic Island消失，但是在锁屏界面会最多保持12个小时。</p>
<p>Live Activity需要用到WidgetKit来实现相关功能，Home Screen Widgets和 Live Activity之间也可以共用代码，但是Live Activity并不是Widget，Widget用timeline来更新界面数据等，而更新Live Activity的更新需要在app内借助ActivityKit框架。</p>
<h3 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h3><p>Live Activity包含两种类型的数据：静态数据和动态数据。以球赛为例，静态数据就是两队的队名、logo等；动态数据就是即时比分、文字直播信息等。需要注意的是每次更新的数据大小不能超过4kb的限制。</p>
<p>AcitivityKit需要我们通过实现ActivityAttributes protocol来描述数据类型，可以想象成data model。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ActivityKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NBAGame</span>: <span class="title class_">ActivityAttributes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">typealias</span> <span class="type">GameState</span> <span class="operator">=</span> <span class="type">ContentState</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> <span class="title class_">ContentState</span>: <span class="title class_">Codable</span>, <span class="title class_">Hashable</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> score1: <span class="type">Int</span></span><br><span class="line">        <span class="keyword">var</span> score2: nt</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> team1: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> team2: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="启动Live-Activity"><a href="#启动Live-Activity" class="headerlink" title="启动Live Activity"></a>启动Live Activity</h3><p>app必须要在前台启动Live Activity,  并且在info.plist里把NSSupportLiveActivities设置为YES。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">func</span> <span class="title function_">request</span>(</span><br><span class="line">    <span class="params">attributes</span>: <span class="type">Attributes</span>,</span><br><span class="line">    <span class="params">content</span>: <span class="type">ActivityContent</span>&lt;<span class="type">Activity</span>&lt;<span class="type">Attributes</span>&gt;.<span class="type">ContentState</span>&gt;,</span><br><span class="line">    <span class="params">pushType</span>: <span class="type">PushType</span>? <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">) <span class="keyword">throws</span> -&gt; <span class="type">Activity</span>&lt;<span class="type">Attributes</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="type">ActivityAuthorizationInfo</span>().areActivitiesEnabled &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// request函数有3个参数</span></span><br><span class="line">        <span class="comment">// attributes 描述静态数据</span></span><br><span class="line">        <span class="comment">// contentState 描述随着时间变化的动态数据</span></span><br><span class="line">        <span class="comment">// pushType 默认为nil，表示通过update方法来更新数据，如果需要通过推送更新则需要传入token</span></span><br><span class="line">        activity <span class="operator">=</span> <span class="keyword">try</span> <span class="type">Activity</span>.request(</span><br><span class="line">            attributes: <span class="type">NBAGame</span>(</span><br><span class="line">                team1: <span class="string">&quot;Lakers&quot;</span>,</span><br><span class="line">                team2: <span class="string">&quot;Celtics&quot;</span></span><br><span class="line">            ),</span><br><span class="line">            contentState: .<span class="keyword">init</span>(</span><br><span class="line">                score1: <span class="number">0</span>,</span><br><span class="line">                score2: <span class="number">0</span></span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">let</span> error) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新Live-Activity"><a href="#更新Live-Activity" class="headerlink" title="更新Live Activity"></a>更新Live Activity</h3><p>虽然启动Live Activify需要在前台进行，但是更新或者停止移除等操作可以通过Background Tasks执行。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">update</span>(<span class="keyword">_</span> <span class="params">content</span>: <span class="type">ActivityContent</span>&lt;<span class="type">Activity</span>&lt;<span class="type">Attributes</span>&gt;.<span class="type">ContentState</span>&gt;) <span class="keyword">async</span></span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> activity.update(using: .<span class="keyword">init</span>(score1: <span class="number">48</span>, score2: <span class="number">50</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止</span></span><br><span class="line"><span class="comment">// ActivityUIDismissalPolicy提供了ui延迟移除的选项，最多可以延迟4小时。</span></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">end</span>(</span><br><span class="line">    <span class="keyword">_</span> <span class="params">content</span>: <span class="type">ActivityContent</span>&lt;<span class="type">Activity</span>&lt;<span class="type">Attributes</span>&gt;.<span class="type">ContentState</span>&gt;?,</span><br><span class="line">    <span class="params">dismissalPolicy</span>: <span class="type">ActivityUIDismissalPolicy</span> <span class="operator">=</span> .default</span><br><span class="line">) <span class="keyword">async</span></span><br><span class="line"></span><br><span class="line"><span class="type">Task</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> activity.end(</span><br><span class="line">        using: .<span class="keyword">init</span>(score1: <span class="number">120</span>, score2: <span class="number">90</span>),</span><br><span class="line">        dismissalPolicy: .immediate</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="展示Live-Activity"><a href="#展示Live-Activity" class="headerlink" title="展示Live Activity"></a>展示Live Activity</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NBAGameActivityWidget</span>: <span class="title class_">Widget</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">WidgetConfiguration</span> &#123;</span><br><span class="line">        <span class="type">ActivityConfiguration</span>(for: <span class="type">NBAGame</span>.<span class="keyword">self</span>) &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 配置锁屏的小组件</span></span><br><span class="line">            <span class="type">SomeActivityView</span>()<span class="operator">...</span></span><br><span class="line">        &#125; dynamicIsland: &#123; context <span class="keyword">in</span></span><br><span class="line">            <span class="comment">// 配置Dynamic Island</span></span><br><span class="line">            <span class="type">DynamicIsland</span> &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; compactLeading: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; compactTrailing: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125; minimal: &#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果app已有Widget并想增加Live Activity的话需要在现有的WdigetBundle里添加</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@main</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PizzaDeliveryWidgets</span>: <span class="title class_">WidgetBundle</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Widget</span> &#123;</span><br><span class="line">        <span class="type">FavoritePizzaWidget</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">#available</span>(<span class="keyword">iOS</span> <span class="number">16.1</span>, <span class="operator">*</span>) &#123;</span><br><span class="line">            <span class="type">NBAGameActivityWidget</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/20/LiveActivity-md/" data-id="cllainvg30005j39kgkfjdod1" data-title="LiveActivity.md" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-Combine Ⅱ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/18/Combine%20%E2%85%A1/" class="article-date">
  <time class="dt-published" datetime="2022-05-18T06:33:31.000Z" itemprop="datePublished">2022-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/18/Combine%20%E2%85%A1/">Combine 浅尝 Ⅱ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>在<strong>Combine Ⅰ</strong>中，我们知道了<strong>What is Combine</strong>和<strong>Why use Combine</strong>，接下来会通过解释<strong>Combine</strong>中各个重要角色的职能去演示<strong>How to Combine</strong>。</p>
<h2 id="Publisher"><a href="#Publisher" class="headerlink" title="Publisher"></a>Publisher</h2><p>顾名思义<strong>发布者</strong>，<strong>Combine</strong>中包括<strong>Publisher</strong>在内的一系列角色都是通过<strong>protocol</strong>去定义的，当初在Swift面世的时候apple就宣布Swift是世界上第一门面向协议编程的语言(POP)，这里也是这一思想的具体体现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Publisher</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Output</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">receive</span>&lt;<span class="type">S</span>&gt;(<span class="params">subscriber</span>: <span class="type">S</span>) <span class="keyword">where</span> <span class="type">S</span> : <span class="type">Subscriber</span>, <span class="keyword">Self</span>.<span class="type">Failure</span> <span class="operator">==</span> <span class="type">S</span>.<span class="type">Failure</span>, <span class="keyword">Self</span>.<span class="type">Output</span> <span class="operator">==</span> <span class="type">S</span>.<span class="type">Input</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Publisher</strong>定义的比较简单，只有两个关联类型和一个<strong>receive</strong>方法，主要职责也比较简单：</p>
<ol>
<li>产生发布事件和数据</li>
<li>准备被<strong>Subscriber</strong>订阅</li>
</ol>
<p><strong>Output</strong>为<strong>Publisher</strong>发布的值的类型，<strong>Failure</strong>为错误类型，对于事件流来说，<strong>Publisher</strong>可以发布三种类型的事件：</p>
<ol>
<li><strong>Output</strong> : 事件流产生了新的值</li>
<li><strong>Failure</strong>:  事件流产生了错误</li>
<li>完成： 事件流结束</li>
</ol>
<p>对于第一种事件仅仅只是发出数据，而<strong>Failure</strong>和完成则是会在<strong>Subscribers.Completion</strong>中描述，其中<strong>Completion</strong>是一个enum， 其中有<strong>finished</strong>和<strong>failure</strong>分别表示着事件流的<strong>结束</strong>和<strong>出错</strong>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// A signal that a publisher doesn’t produce additional elements, either due to normal completion or an error.</span></span><br><span class="line"><span class="keyword">@frozen</span> <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Completion</span>&lt;<span class="title class_">Failure</span>&gt; <span class="title class_">where</span> <span class="title class_">Failure</span> : <span class="title class_">Error</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> finished</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Failure</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h2><p><strong>Publisher</strong>仅仅负责发送事件和数据，如果你想改变App内的某些”状态”，那么还需要<strong>Operator</strong>。</p>
<p>以<strong>append</strong>为例</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">append</span>(<span class="keyword">_</span> <span class="params">elements</span>: <span class="keyword">Self</span>.<span class="type">Output</span>...) -&gt; <span class="type">Publishers</span>.<span class="type">Concatenate</span>&lt;<span class="keyword">Self</span>, <span class="type">Publishers</span>.<span class="type">Sequence</span>&lt;[<span class="keyword">Self</span>.<span class="type">Output</span>], <span class="keyword">Self</span>.<span class="type">Failure</span>&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>他接受的参数类型必须要与<strong>上游Publisher</strong>的<strong>Output</strong>类型一致，并生成一个新的<strong>Publisher</strong>传递下去。它的功能也是顾名思义，将特定数据与上游Publisher的Output数据进行一个拼接。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dataElements <span class="operator">=</span> (<span class="number">0</span><span class="operator">...</span><span class="number">10</span>) <span class="comment">// 0 1 2 3 4 5 6 7 8 9 10</span></span><br><span class="line">cancellable <span class="operator">=</span> dataElements.publisher</span><br><span class="line">    .append(<span class="number">0</span>, <span class="number">1</span>, <span class="number">255</span>) <span class="comment">// 需要拼接的数据</span></span><br><span class="line">    .sink &#123; <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(<span class="variable">$0</span>)</span>&quot;</span>, terminator: <span class="string">&quot; &quot;</span>) &#125;</span><br><span class="line">         <span class="comment">// Prints: &quot;0 1 2 3 4 5 6 7 8 9 10 0 1 255&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>Combine</strong>提供很多方便的<strong>Operator</strong>， 像是使用频率很高的<strong>map</strong>、<strong>flatmap</strong>等等，它们命名都比较简单并且也很容易知道其对应的职责。</p>
<p>在响应式编程中，绝大部分逻辑都发生在数据处理和变形中。每个<strong>Operator</strong>的模式都一样，接收上游Publisher的数据，进行变形、处理，然后再产生一个新的Publisher传给下游。</p>
<p><strong>Subscriber</strong></p>
<p>事件的发生，数据的处理都已经有了，接下来需要去“<strong>接收</strong>“、”<strong>消费</strong>“上游的数据，这时候就需要<strong>Subscriber</strong>订阅者。</p>
<p>和<strong>Publisher</strong>类似， <strong>Subscriber</strong>也是一个抽象的协议，它定义了某个类型想要成为订阅者应该要满足的条件。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">protocol</span> <span class="title class_">Subscriber</span> : <span class="title class_">CustomCombineIdentifierConvertible</span> &#123;</span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Input</span></span><br><span class="line">    <span class="keyword">associatedtype</span> <span class="type">Failure</span> : <span class="type">Error</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">receive</span>(<span class="params">subscription</span>: <span class="type">Subscription</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">receive</span>(<span class="keyword">_</span> <span class="params">input</span>: <span class="keyword">Self</span>.<span class="type">Input</span>) -&gt; <span class="type">Subscribers</span>.<span class="type">Demand</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">receive</span>(<span class="params">completion</span>: <span class="type">Subscribers</span>.<span class="type">Completion</span>&lt;<span class="keyword">Self</span>.<span class="type">Failure</span>&gt;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中的<strong>Input</strong>和<strong>Failure</strong>分别表示订阅者能够接收的事件流数据类型和错误类型，想要订阅某个<strong>Publisher</strong>，<strong>Subscriber</strong>中的<strong>Input</strong>和<strong>Failure</strong>必须要跟<strong>Publisher</strong>中的<strong>Output</strong>和<strong>Failure</strong>一致。</p>
<p><strong>Combine</strong>中也定义了很多常用的<strong>Subscriber</strong>，这里用<strong>sink</strong>来举例。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">func</span> <span class="title function_">sink</span>(<span class="params">receiveCompletion</span>: <span class="keyword">@escaping</span> ((<span class="type">Subscribers</span>.<span class="type">Completion</span>&lt;<span class="keyword">Self</span>.<span class="type">Failure</span>&gt;) -&gt; <span class="type">Void</span>), <span class="params">receiveValue</span>: <span class="keyword">@escaping</span> ((<span class="keyword">Self</span>.<span class="type">Output</span>) -&gt; <span class="type">Void</span>)) -&gt; <span class="type">AnyCancellable</span></span><br></pre></td></tr></table></figure>

<p><strong>sink</strong>方法中你可以提供两个<strong>closure</strong>，<strong>receiveCompletion</strong>用来接收<strong>finish</strong>或者<strong>failure</strong>事件，而<strong>receiveValue</strong>就是接受上游的<strong>Output</strong>值。</p>
<p><strong>Subscriber</strong>的作用相当于一座桥梁，将响应函数式代码终结并桥接到指令式代码中(Closure中)。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从<strong>Publisher</strong>-&gt;<strong>Operator</strong>-&gt;<strong>Subscriber</strong>，从事件发布-&gt;变形-&gt;订阅接收，随着事件的发生，App的状态也随之改变，这些就是响应式框架<strong>Combine</strong>的基本架构。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/18/Combine%20%E2%85%A1/" data-id="cllainvg10001j39k1ay8ajlk" data-title="Combine 浅尝 Ⅱ" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Combine Ⅰ" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/05/17/Combine%20%E2%85%A0/" class="article-date">
  <time class="dt-published" datetime="2022-05-17T06:30:27.000Z" itemprop="datePublished">2022-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2022/05/17/Combine%20%E2%85%A0/">Combine 浅尝 Ⅰ</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="old-tricks"><a href="#old-tricks" class="headerlink" title="old tricks"></a>old tricks</h2><p>对于一个iOS App，99%会有如下的异步的编程场景：</p>
<ul>
<li>请求API返回JSON</li>
<li>网络加载图片并下载持久化</li>
</ul>
<p>传统的Cocoa和UIKit框架则提供了异步API三巨头：</p>
<ul>
<li><strong>Block\Closure</strong>: 调用耗时方法提供Block\Closure接受回调，耗时方法在非主线程中执行，完成时执行Block\Closure通知调用者任务完成。例子：<strong>URLSession</strong>的网络请求方法<strong>dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask</strong>中的<strong>completionHandler</strong></li>
<li><strong>Protocol-Delegate</strong>: 定义一个protocol和其中的方法来描述异步行为中可能发生的结果，使用时创建遵循该protocol并实现其中的方法的delegate，异步行为完成后会检查是否有符合条件的delegate，并会尝试执行protocol中的方法来通知行为的完成。例子：<strong>UITableView</strong>的<strong>UITableViewDataSource</strong>和<strong>UITableViewDelegate</strong>， 用于描述UITableView该如何展示。同时<strong>URLSession</strong>中除了<strong>Block\Closure</strong>回调方式也有基于<strong>Protocol-Delegate</strong>的回调方式。</li>
<li><strong>Notification</strong>: 可以通过<strong>NotificationCenter</strong>发送一个<strong>Notification</strong>， 这个<strong>Notification</strong>会被注册的观察者所接收到并且执行相应的代码。这也是<strong>Cocoa</strong>中常见的观察者模式。例子：键盘将要展示的 <strong>UIKeyboardWillShowNotification</strong>。</li>
</ul>
<p>这三种方式我认为并没有优劣之分，只有各自擅长的使用场景之分，如果事件比较简单不需要关心过程，则使用<strong>Block-Closure</strong>，如果需要关心更多的过程与细节，则使用<strong>Protocol-Delegate</strong>比较合理。如果触发时机不规律则会使用<strong>Notification</strong>。</p>
<h2 id="problems"><a href="#problems" class="headerlink" title="problems"></a>problems</h2><p>如果只有一两个异步操作和状态时，对这些状态的管理不会特别困难。但在实际开发中，往往需要混合调用多个不同类型的异步 API，而有时候这些不同的异步 API 会操作和设置同一个状态。因为无法确定这些异步 API 的调用顺序，这会让状态的维护成本变得很高，进而导致逻辑复杂，导致Bug。</p>
<p>解决这些有关联并且逻辑复杂的问题时，通常会寻找这些问题的共同点，在上一层进行抽象总结对各个问题的通用方案。无论是<strong>Block\Closure</strong>还是<strong>Protocol-Delegate</strong>或者是<strong>Notification</strong>，其实都是提前写好逻辑，去相应未来发生的事件。<strong>Combine</strong>框架提供了另外一种方式去模糊不同异步API的区别，让事件发生这一核心概念暴露出来，在异步操作中某个事件发生时，把这个事件和与其相关的数据<strong>publish</strong>出来。而对这个事件感兴趣的可以<strong>subscribe</strong>这个事件，来进行后续操作。</p>
<p>这种方式接受事件的行为与<strong>Notification</strong>有那么一点类似，但是最大的区别就是后续处理数据的方式，<strong>Combine</strong>框架中事件和与其相关的数据<strong>publish</strong>后，我们可以在事件流中按需处理\改变这些事件和数据。事件中的数据不符合需要的格式，我们可以进行一系列变形操作。事件中的某些数据并不需要，我们可以将其过滤。A事件的数据需要与B事件的数据合并，我们可以先把A事件数据“暂存”起来，等待B事件数据后再进行合并。随后在末端会有个<strong>subscriber</strong>来接受事件和数据的最终形态。</p>
<h2 id="new-tricks"><a href="#new-tricks" class="headerlink" title="new tricks"></a>new tricks</h2><p>正如<strong>Combine</strong>其名，通过<strong>组合</strong>事件处理操作来自定义处理异步操作。响应式编程并不是什么新概念，OC的<strong>ReactiveCocoa</strong>和Swift的<strong>RxSwift</strong>，虽然他们的实现略有差异，但是核心思想都是一致的，而<strong>Combine</strong>这个“正规军”的出现，则从系统层级对响应式编程提供了完备的支持。<strong>Combine</strong>中有三个重要的角色<strong>Publisher</strong>、<strong>Operator</strong>和<strong>Subscriber</strong>, 下一篇将会对这三个角色进行详细说明。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/05/17/Combine%20%E2%85%A0/" data-id="cllainvfy0000j39k4gzibr6f" data-title="Combine 浅尝 Ⅰ" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Combine/" rel="tag">Combine</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-swiftui-property-wrapper" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/02/28/swiftui-property-wrapper/" class="article-date">
  <time class="dt-published" datetime="2021-02-28T06:40:03.000Z" itemprop="datePublished">2021-02-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/02/28/swiftui-property-wrapper/">SwiftUI中的常用的属性包装器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>整理一些SwiftUI中常用的属性包装器(Property Wrappers).</p>
<ul>
<li><p><code>@Binding</code>用于标记其他View持有的值类型数据(例如父View传入子View的参数)，改变本地binding的值会同时改变原始的值。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayerView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> episode: <span class="type">Episode</span></span><br><span class="line">    <span class="meta">@State</span> <span class="keyword">private</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span> <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Text</span>(episode.title)</span><br><span class="line">            <span class="type">Text</span>(episode.showTitle)</span><br><span class="line">          <span class="comment">// isPlaying作为参数传给子View</span></span><br><span class="line">            <span class="type">PlayButton</span>(isPlaying: <span class="variable">$isPlaying</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PlayButton</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@Binding</span> <span class="keyword">var</span> isPlaying: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Button</span>(action: &#123;</span><br><span class="line">          <span class="comment">// 改变local的isPlaying也同时会改变PlayerView中的isPlaying</span></span><br><span class="line">            <span class="keyword">self</span>.isPlaying.toggle()</span><br><span class="line">        &#125;) &#123;</span><br><span class="line">            <span class="type">Image</span>(systemName: isPlaying <span class="operator">?</span> <span class="string">&quot;pause.circle&quot;</span> : <span class="string">&quot;play.circle&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Enviroment</code>用于读取系统的配置，例如系统当前是否为黑夜模式。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Environment</span>(\.colorScheme) <span class="keyword">var</span> colorScheme: <span class="type">ColorScheme</span></span><br><span class="line"><span class="comment">//如果colorScheme变了，SwiftUI会更新使用到这些值的View, 适用于如果用户手动改变系统主题偏好设置。</span></span><br><span class="line"><span class="keyword">if</span> colorScheme <span class="operator">==</span> .dark &#123; </span><br><span class="line">    <span class="type">DarkContent</span>()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="type">LightContent</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@EnviromentObject</code>用于标记我们注入<code>enviroment</code>中的共享对象，例如View A使用了<code>@EnviromentObject</code>标记了一个对象属性Object_A，那么View A中的所有View都可以在这个’环境’中访问到这个Object_A, 而不需要以参数的形式传递。</p>
</li>
<li><p><code>@ObservedObject</code> 用于标记外部创建的类的实例对象，并且该类遵循<strong>ObservableObject</strong>这个协议。<code>@ObservedObject</code>与<code>@StateObject</code>有点类似，除了<code>@ObservedObject</code>用于外部创建的对象，因为SwiftUI有可能会意外销毁这些标记的对象，例如页面重绘，而<code>@StateObject</code>就不会。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="comment">// ObservableObject 的类中通常会配合 @Published使用</span></span><br><span class="line">  <span class="comment">// 当items发生变化时会通知到ContentView</span></span><br><span class="line">    <span class="meta">@Published</span> <span class="keyword">var</span> items <span class="operator">=</span> [<span class="type">String</span>]()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">    <span class="meta">@ObservedObject</span> <span class="keyword">var</span> order: <span class="type">Order</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> order.items.count <span class="operator">&gt;</span> <span class="number">10</span> &#123;</span><br><span class="line">        <span class="comment">// items变化时会按需更新使用到的View </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@StateObject</code>通常用于View中创建的类的实例对象，当View更新的时候，该实例对象不会被销毁重新创建。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>: <span class="title class_">ObservableObject</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> username <span class="operator">=</span> <span class="string">&quot;@twostraws&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ContentView</span>: <span class="title class_">View</span> &#123;</span><br><span class="line">  <span class="comment">// user在View重绘的时候不会重新生成</span></span><br><span class="line">    <span class="meta">@StateObject</span> <span class="keyword">var</span> user <span class="operator">=</span> <span class="type">User</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">&quot;Username: <span class="subst">\(user.username)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@Published</code>用于标记<strong>ObservableObject</strong>中需要观察的属性，SwiftUI会自动监控这些属性，并且在值改变时更新与其关联的View。</p>
</li>
<li><p>SwiftUI会管理所有用<code>@State</code>标记的属性，当<code>@State</code>标记的属性发生变化时，关联的View会重绘。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/02/28/swiftui-property-wrapper/" data-id="cllainvg4000cj39k3eaw5kr3" data-title="SwiftUI中的常用的属性包装器" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SwiftUI/" rel="tag">SwiftUI</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-swift-closure" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/01/03/swift-closure/" class="article-date">
  <time class="dt-published" datetime="2021-01-03T06:38:42.000Z" itemprop="datePublished">2021-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/01/03/swift-closure/">Swift中闭包的本质</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <ul>
<li>Swift中闭包相关的概念</li>
</ul>
<ol>
<li><p>一个函数和它所捕获的变量\常量环境组合起来，称作闭包.</p>
</li>
<li><p>一般指定义在函数内部的函数.</p>
</li>
<li><p>一般它捕获的是外层函数的局部变量\常量.</p>
</li>
</ol>
<ul>
<li>利用汇编理解闭包本质</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typealias</span> <span class="type">Fn</span> <span class="operator">=</span> (<span class="type">Int</span>) -&gt; <span class="type">Int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">func</span> <span class="title function_">getFn</span>() -&gt; <span class="type">Fn</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">plus</span>(<span class="keyword">_</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num <span class="operator">+=</span> i</span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn <span class="operator">=</span> getFn()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(fn(<span class="number">1</span>)) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">print</span>(fn(<span class="number">2</span>)) <span class="comment">//3</span></span><br><span class="line"><span class="built_in">print</span>(fn(<span class="number">3</span>)) <span class="comment">//6</span></span><br><span class="line"><span class="built_in">print</span>(fn(<span class="number">4</span>)) <span class="comment">//10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的示例代码中闭包<code>plus</code>内部使用了外部变量<code>num</code> 并进行一系列操作，而后将<code>getFn()</code>赋值给变量<code>fn</code>，再通过传入不同的参数执行<code>fn</code>， 得到的结果为1， 3，6，10说明<code>num</code>是被<code>plus</code>“捕获”了，但是<code>plus</code>究竟是如何捕获<code>num</code>的还是要借助断点+汇编代码去一探究竟。</p>
<p>首先先看<code>plus没有访问num</code>变量时的情况，我们将断点打在<code>return plus</code>处</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getFn</span>() -&gt; <span class="type">Fn</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">plus</span>(<span class="keyword">_</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plus <span class="comment">//断点处</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TestSwift`getFn():</span><br><span class="line">    0x100003e90 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100003e91 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100003e94 &lt;+4&gt;:  movq   $0x0, -0x8(%rbp)</span><br><span class="line">-&gt;  0x100003e9c &lt;+12&gt;: leaq   0xd(%rip), %rax           ; plus #1 (Swift.Int) -&gt; Swift.Int in TestSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at main.swift:14</span><br><span class="line">    0x100003ea3 &lt;+19&gt;: xorl   %ecx, %ecx</span><br><span class="line">    0x100003ea5 &lt;+21&gt;: movl   %ecx, %edx</span><br><span class="line">    0x100003ea7 &lt;+23&gt;: popq   %rbp</span><br><span class="line">    0x100003ea8 &lt;+24&gt;: retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由断电的命令<code>leaq</code>可以得知，其实<code>getFn()</code>是把0xd+rip的地址 值扔进了<code>rax</code>中。</p>
<p>因为返回值一般会存放在<code>rax</code>寄存器中，因为<code>getFn</code>函数返回的是<code>plus</code>闭包，所以<code>rax</code>中是存放着<code>plus</code>的地址，<code>rax</code>的值可以通过<code>lldb</code>命令在<code>xcode</code>的控制台中获取。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(lldb) si</span><br><span class="line">(lldb) register read rax</span><br><span class="line">     rax = 0x0000000100003eb0  TestSwift`plus #1 (Swift.Int) -&gt; Swift.Int in TestSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at main.swift:14</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p><code>rip</code>的地址<code>0x100003ea3</code>加上<code>0xd</code>正好是<code>0x0000000100003eb0</code></p>
<p>接下来看看<code>plus</code>访问了<code>num</code>的情况, 断点还是打在<code>retrun plus</code>。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">func</span> <span class="title function_">getFn</span>() -&gt; <span class="type">Fn</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> num <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">plus</span>(<span class="keyword">_</span> <span class="params">i</span>: <span class="type">Int</span>) -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        num <span class="operator">+=</span> i</span><br><span class="line">        <span class="keyword">return</span> num </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> plus</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时候的汇编代码就复杂了许多。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">TestSwift`getFn():</span><br><span class="line">    0x100003cf0 &lt;+0&gt;:  pushq  %rbp</span><br><span class="line">    0x100003cf1 &lt;+1&gt;:  movq   %rsp, %rbp</span><br><span class="line">    0x100003cf4 &lt;+4&gt;:  subq   $0x20, %rsp</span><br><span class="line">    0x100003cf8 &lt;+8&gt;:  movq   $0x0, -0x8(%rbp)</span><br><span class="line">    0x100003d00 &lt;+16&gt;: leaq   0x321(%rip), %rdi</span><br><span class="line">    0x100003d07 &lt;+23&gt;: movl   $0x18, %esi</span><br><span class="line">    0x100003d0c &lt;+28&gt;: movl   $0x7, %edx</span><br><span class="line">    0x100003d11 &lt;+33&gt;: callq  0x100003ee6               ; symbol stub for: swift_allocObject</span><br><span class="line">    0x100003d16 &lt;+38&gt;: movq   %rax, %rcx</span><br><span class="line">    0x100003d19 &lt;+41&gt;: addq   $0x10, %rcx</span><br><span class="line">    0x100003d1d &lt;+45&gt;: movq   %rcx, -0x8(%rbp)</span><br><span class="line">    0x100003d21 &lt;+49&gt;: movq   $0x0, 0x10(%rax)</span><br><span class="line">-&gt;  0x100003d29 &lt;+57&gt;: movq   %rax, %rdi</span><br><span class="line">    0x100003d2c &lt;+60&gt;: movq   %rax, -0x10(%rbp)</span><br><span class="line">    0x100003d30 &lt;+64&gt;: callq  0x100003f0a               ; symbol stub for: swift_retain</span><br><span class="line">    0x100003d35 &lt;+69&gt;: movq   -0x10(%rbp), %rdi</span><br><span class="line">    0x100003d39 &lt;+73&gt;: movq   %rax, -0x18(%rbp)</span><br><span class="line">    0x100003d3d &lt;+77&gt;: callq  0x100003f04               ; symbol stub for: swift_release</span><br><span class="line">    0x100003d42 &lt;+82&gt;: leaq   0x177(%rip), %rax         ; partial apply forwarder for plus #1 (Swift.Int) -&gt; Swift.Int in TestSwift.getFn() -&gt; (Swift.Int) -&gt; Swift.Int at &lt;compiler-generated&gt;</span><br><span class="line">    0x100003d49 &lt;+89&gt;: movq   -0x10(%rbp), %rdx</span><br><span class="line">    0x100003d4d &lt;+93&gt;: addq   $0x20, %rsp</span><br><span class="line">    0x100003d51 &lt;+97&gt;: popq   %rbp</span><br><span class="line">    0x100003d52 &lt;+98&gt;: retq   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>里面有个关键点是使用了<code>swift_allocObject</code>这个函数，使用了这个函数以为这开辟了堆空间，所以可以直接联想这个新开辟的堆空间是跟<code>num</code>有关的，或许是拿来存放<code>num</code>的。这也解释了为什么<code>num</code>没有在<code>getFn()</code>作用域结束时没有销毁，所以<code>num</code>的值才能累加起来。</p>
<p>现在就来看看<code>swift_allocObject</code>分配的堆空间内是否存放着<code>num</code>，需要在分配完毕时打汇编断点并打印<code>rax</code>的值， 此时<code>rax</code>的值就是堆空间返回的地址。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">   0x100003d11 &lt;+33&gt;: callq  0x100003ee6               ; symbol stub for: swift_allocObject</span><br><span class="line">-&gt; 0x100003d16 &lt;+38&gt;: movq   %rax, %rcx</span><br></pre></td></tr></table></figure>
<p>读取到<code>rax</code>的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read rax</span><br><span class="line">     rax = 0x00000001018067d0</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p>此时将代码断点<code>return plus</code>的断点去掉，并新加<code>return num</code>的断点，目的是观察<code>num</code>值改变时，堆空间有没有变化，如果有变化就能证明<code>num</code>确实是在堆空间内。 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(lldb) register read rax</span><br><span class="line">     rax = 0x00000001018067d0</span><br><span class="line">(lldb) x/5xg 0x00000001018067d0</span><br><span class="line">0x1018067d0: 0x0000000100004028 0x0000000200000003</span><br><span class="line">0x1018067e0: 0x0000000000000001 0x00007fff7f0bc658</span><br><span class="line">0x1018067f0: 0x0000000000000000</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p><code>x/数量+格式+字节大小 地址</code>读取内存中的值。</p>
<p>因为此时调用<code>fn(1)</code>, <code>num</code>初始化的值为<code>1</code>,  在<code>0x1018067e0</code>地址中的<code>8</code>个字节也为<code>1</code>(<code>0x0000000000000001</code>)，于是继续程序的执行，看下次到达断点时那8个字节会不会因为<code>fn(2)</code>的调用而变成<code>3</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(lldb) x/5xg 0x00000001018067d0</span><br><span class="line">0x1018067d0: 0x0000000100004028 0x0000000200000003</span><br><span class="line">0x1018067e0: 0x0000000000000001 0x00007fff7f0bc658</span><br><span class="line">0x1018067f0: 0x0000000000000000</span><br><span class="line">1</span><br><span class="line">(lldb) x/5xg 0x00000001018067d0</span><br><span class="line">0x1018067d0: 0x0000000100004028 0x0000000200000003</span><br><span class="line">0x1018067e0: 0x0000000000000003 0x00007fff7f0bc658</span><br><span class="line">0x1018067f0: 0x00007fff88997f98</span><br><span class="line">(lldb) </span><br></pre></td></tr></table></figure>

<p><code>0x1018067e0</code>地址的<code>8</code>个字节确实变成了<code>3</code>，也证明了<code>num</code>确实存在新开辟的堆空间中。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以把闭包想象成是一个类的实例对象</p>
<p>内存在堆空间</p>
<p>捕获的局部变量\常量就是对象的成员</p>
<p>组成闭包的函数就是类内部定义的方法</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/01/03/swift-closure/" data-id="cllainvg40009j39k9upb3ygm" data-title="Swift中闭包的本质" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/" rel="tag">零碎知识</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-iOS-14" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/10/07/iOS-14/" class="article-date">
  <time class="dt-published" datetime="2020-10-07T06:36:20.000Z" itemprop="datePublished">2020-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2020/10/07/iOS-14/">iOS 14相册相关变更要点</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="功能预览"><a href="#功能预览" class="headerlink" title="功能预览"></a>功能预览</h2><p>在iOS 14之前，一旦允许访问相册，App是可以通过Photos框架 APIs<strong>读取</strong>&#x2F;<strong>写入</strong>你的手机相册。</p>
<img src="https://i.loli.net/2020/10/07/8ZTHxosPkJfepE5.png" width="400px" />

<p>而在iOS 14中，则新增了一种模式叫做<strong>Limited photo library access</strong>，你可以将其视为PhotoKit API的一层过滤器，App只能访问用户选定的媒体资料而不是整个媒体库。</p>
<img src="https://i.loli.net/2020/10/07/3O1CQLw6ogvHmKE.png" width="400px" />

<p>当用户修改了他们的选择时，App将会自动收到通知，这样就可以更新UI来反应用户的操作。</p>
<p>这次新加的模式将会影响所有使用PhotoKit的iOS 14应用，已经上架的应用也不例外。</p>
<h2 id="授权弹窗"><a href="#授权弹窗" class="headerlink" title="授权弹窗"></a>授权弹窗</h2><p>当用户首次打开App内相册时通常都会遇到这个弹窗。</p>
<img src="https://i.loli.net/2020/10/08/SDCgMTtRmwBXNl3.png" width="400px" />

<ul>
<li><p><strong>Select Photos</strong>: 有限访问权限，点击后系统会要求用户选择提供给App的媒体资源。</p>
</li>
<li><p><strong>Allow Access to All Photos</strong>: 完全访问权限。</p>
</li>
<li><p><strong>Don’t Allow</strong>: 不允许访问权限。</p>
</li>
</ul>
<h2 id="有限访问"><a href="#有限访问" class="headerlink" title="有限访问"></a>有限访问</h2><p>点击<strong>Select Photos</strong>后，会弹出一个系统级的媒体资源选择器提供给用户选择。</p>
<img src="https://i.loli.net/2020/10/08/mtNqS7YE5nk8Jdw.png" width="400px" />

<img src="https://i.loli.net/2020/10/08/nahWog2v63fFX4S.png" width="400px" />

<h2 id="修改已选择项"><a href="#修改已选择项" class="headerlink" title="修改已选择项"></a>修改已选择项</h2><ul>
<li>可以在设置中找到对应App，修改已选中的媒体资源。</li>
</ul>
<img src="https://i.loli.net/2020/10/08/y7XtdkFirUTR9hv.png" width="400px" />

<img src="https://i.loli.net/2020/10/08/3wKZHbCdJtpOBRN.png" width="400px" />

<img src="https://i.loli.net/2020/10/08/5o2SxnftZdQTUyK.png" width="400px" />

<img src="https://i.loli.net/2020/10/08/5axYfUg8T7D3QbH.png" width="400px" />

<ul>
<li><p>冷启动首次在App中使用相册功能时，也可以修改已选的媒体资源。</p>
<img src="https://i.loli.net/2020/10/08/t3USKMEGszqmTcJ.png" width="400px" />

<h2 id="Photos框架API变更"><a href="#Photos框架API变更" class="headerlink" title="Photos框架API变更"></a>Photos框架API变更</h2><ul>
<li><p>在<strong>PHAuthorizationStatus</strong>(授权状态)枚举中增加了<strong>limited</strong>枚举值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public enum PHAuthorizationStatus : Int &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case notDetermined = 0 // User has not yet made a choice with regards to this application</span><br><span class="line"></span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case restricted = 1 // This application is not authorized to access photo data.</span><br><span class="line"></span><br><span class="line">    // The user cannot change this application’s status, possibly due to active restrictions</span><br><span class="line">    //   such as parental controls being in place.</span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case denied = 2 // User has explicitly denied this application access to photos data.</span><br><span class="line"></span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case authorized = 3 // User has authorized this application to access photos data.</span><br><span class="line"></span><br><span class="line">    @available(iOS 14, *)</span><br><span class="line">    case limited = 4 // User has authorized this application for limited photo library access. Add PHPhotoLibraryPreventAutomaticLimitedAccessAlert = YES to the application&#x27;s Info.plist to prevent the automatic alert to update the users limited library selection. Use -[PHPhotoLibrary(PhotosUISupport) presentLimitedLibraryPickerFromViewController:] from PhotosUI/PHPhotoLibrary+PhotosUISupport.h to manually present the limited library picker.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p>增加<strong>PHAccessLevel</strong>枚举值，分别代表两种相册访问方式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public enum PHAccessLevel : Int &#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case addOnly = 1</span><br><span class="line"></span><br><span class="line">    @available(iOS 8, *)</span><br><span class="line">    case readWrite = 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加两个替换性API，分别用于查询相册授权状态API和请求授权API，增加了<strong>accessLevel</strong>的传入参数，值得注意的是，旧的API已经被打上<strong>deprecated</strong>标签。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/// Replaces \c +authorizationStatus to support add-only/read-write access level status</span><br><span class="line">@available(iOS 14, *)</span><br><span class="line">open class func authorizationStatus(for accessLevel: PHAccessLevel) -&gt; PHAuthorizationStatus</span><br><span class="line">    </span><br><span class="line">@available(iOS 14, *)</span><br><span class="line">open class func requestAuthorization(for accessLevel: PHAccessLevel, handler: @escaping (PHAuthorizationStatus) -&gt; Void)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">/// Deprecated and replaced by authorizationStatusForAccessLevel:, will return \c PHAuthorizationStatusAuthorized if the user has chosen limited photo library access</span><br><span class="line">@available(iOS, introduced: 8, deprecated: 100000)</span><br><span class="line">open class func authorizationStatus() -&gt; PHAuthorizationStatus</span><br><span class="line">    </span><br><span class="line">@available(iOS, introduced: 8, deprecated: 100000)</span><br><span class="line">open class func requestAuthorization(_ handler: @escaping (PHAuthorizationStatus) -&gt; Void)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>Apple在iOS 14进行相册权限的改动是为了让开发者重新审视自己的App是否真的需要用户的完全相册权限，旨在保护用户的隐私。Apple认为只有以下类型的App才可能需要用户相册的完全权限。</p>
<img src="https://i.loli.net/2020/10/08/YUR2iwAdabqlnLO.png" width="400px" />

<h2 id="PHPicker"><a href="#PHPicker" class="headerlink" title="PHPicker"></a>PHPicker</h2><p>Apple建议在readOnly的情景下使用新推出的<strong>PHPicker</strong>，所以在<strong>PHAccessLevel</strong>中并没有<strong>readOnly</strong>的枚举值，iOS 14之前<strong>PHPicker</strong>的前任是<strong>UIImagePickerController</strong>。</p>
<img src="https://i.loli.net/2020/10/08/IBhOdSQoRzvrGEe.png" width="400px" />

<p>相比于自定义相册，<strong>PHPicker</strong>有几个优势:</p>
<ul>
<li>独立进程，不影响App性能。</li>
<li>默认多选。</li>
<li>默认支持搜索。</li>
<li>没有授权弹窗。</li>
<li>App不需要直接访问媒体库来显示选择器。</li>
<li>只提供用户选择的照片和视频。</li>
</ul>
<p>劣势就是无法定制化，如果需要定制UI还是需要使用Photos框架自己写一个图片选择器。</p>
<h2 id="隐藏选择图片弹窗"><a href="#隐藏选择图片弹窗" class="headerlink" title="隐藏选择图片弹窗"></a>隐藏选择图片弹窗</h2><p>在上面说过，用户选择了<strong>limited</strong>模式后，App第一次冷启动时还是会显示一个弹窗。</p>
<img src="https://i.loli.net/2020/10/08/t3USKMEGszqmTcJ.png" width="400px" />

<p>Apple建议关闭自动弹窗，建议在App其他页面提供修改已选媒体资源的入口，例如设置页。</p>
<p>若要关闭此自动弹窗，需要改动<strong>info.plist</strong>，增加一个新的key: <strong>PHPhotoLibraryPreventAutomaticLimitedAccessAlert</strong>，将其设置为<strong>YES</strong>即可。</p>
<p>参考WWDC Session:</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10641/">Handle the Limited Photos Library in your app</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/videos/play/wwdc2020/10652">Meet the new Photos picker</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/10/07/iOS-14/" data-id="cllainvg40007j39kffps6ua0" data-title="iOS 14相册相关变更要点" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li></ul>

    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Combine/" rel="tag">Combine</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/KMP/" rel="tag">KMP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SwiftUI/" rel="tag">SwiftUI</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/" rel="tag">iOS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/" rel="tag">零碎知识</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Combine/" style="font-size: 10px;">Combine</a> <a href="/tags/KMP/" style="font-size: 15px;">KMP</a> <a href="/tags/SwiftUI/" style="font-size: 10px;">SwiftUI</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">零碎知识</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">January 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/12/">December 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">May 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/14/KMP-Key-Value-md/">KMP数据持久化之Key-Value</a>
          </li>
        
          <li>
            <a href="/2023/01/02/KMP-Serialization-md/">KMP中的序列化</a>
          </li>
        
          <li>
            <a href="/2022/12/20/LiveActivity-md/">LiveActivity.md</a>
          </li>
        
          <li>
            <a href="/2022/05/18/Combine%20%E2%85%A1/">Combine 浅尝 Ⅱ</a>
          </li>
        
          <li>
            <a href="/2022/05/17/Combine%20%E2%85%A0/">Combine 浅尝 Ⅰ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 Evan Hong<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>